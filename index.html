<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>machinamentum&#39;s word stuff by machinamentum</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>machinamentum&#39;s word stuff</h1>
        <p></p>


        <p class="view"><a href="https://github.com/machinamentum">View My GitHub Profile</a></p>

      </header>
      <section>
        <h2>
<a id="proposition-for-a-better-os" class="anchor" href="#proposition-for-a-better-os" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Proposition for a better OS</h2>

<h3>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h3>

<p>Over the past few years I've been increasingly losing interest in interacting with major operating systems for my day-to-day needs. Major operating systems have become largely bloatware that is more intrusive to the user's experience than it is useful. I will try to outline the surface features at this time. Features that are non-user facing (within the kernel, programming interface, etc..) will be outlined at a later time.</p>

<p>These are the basic philosophies for designing this new OS:</p>

<ol>
<li>Operating systems should be designed to help the user get from point A to point B or perform task XYZ with as little friction as possible.</li>
<li>A design choice should not compromise philosophy(1), or philosophy(2).</li>
<li>The OS should be stripped of all bloatware.</li>
<li>The OS should be as unintrusive to the user as possible.</li>
<li>Upgrading the OS should improve the user's experience, not degrade it.</li>
<li>The OS should be as easy and as accessible as possible; it should support multiple points of interaction by default. Whether the user wants to use a keyboard and mouse, a touch screen, or even a gamepad, the OS should be agnostic to these common points of interaction and should provide a pleasant experience.</li>
</ol>

<h3>
<a id="the-terminal" class="anchor" href="#the-terminal" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Terminal</h3>

<p>Currently, command terminals support basic IO, command execution, and simple text rendering (coloring, italics, bold face, etc..). These aren't bad features at all, this small feature set is what makes interacting with consoles still a pretty good experience. However, this limiting feature set induces poor implementation choices of software that uses the console as a primary user interface. A prime example of a such program is the GNU debugger. GDB is an otherwise good debugger, but it's console-based user interface makes even the most trivial of debugging tasks impossible to efficiently get done. We could do better.</p>

<p><strong>Bitmap rendering</strong>
I first heard about this idea from Gary Bernhardt of Destroy All Software in his talk <a href="https://www.destroyallsoftware.com/talks/a-whole-new-world">A Whole New World</a>. Although Gary mentions a few interesting uses for terminal raster graphics, there's much wider implications of what this feature would be capable of. This enables full-featured UI's from within a terminal. A terminal app could render a webpage, draw game graphics, or display a powerpoint. Typically, a terminal app like (for example) <a href="http://gource.io/">gource</a> would have to open a separate window to draw its output. The user then has to exit the newly opened window the click back into the terminal. This is unneeded friction that does nothing but waste the user's time.</p>

<p><strong>Mouse/agnostic pointer input</strong>
Since we have to support philosophy(6). The terminal should be able to do more with a pointer device than just copy-paste. As a natural, harmonious progression with bitmap rendering, a terminal app should be able to capture basic pointer input like position and clicking/tapping.</p>

<p><strong>Scripting language</strong>
The terminal should support a robust scripting language to allow the user to automate tasks or interact with the system. Although this is a current feature of most terminals, many terminal languages are designed to do most of their work in the form of executing other terminal programs. Scripts in this language should be native to the system; they should be able to work like any other program without having to invoke other terminal programs to perform a task.</p>

<h3>
<a id="windowing-system" class="anchor" href="#windowing-system" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Windowing system</h3>

<p>Although the features proposed in <em>The Terminal</em> would make windowing obsolete, there's still a major use for apps exclusively designed around a window system. The terminal is typically thought of as a power-user-y interface; it inherently requires a keyboard and a bit of learning to effectively use it. A windowing system still provides a smaller amount of friction than the terminal.</p>

<p>iOS and Window's MetroUI are forward-thinking systems. They maximize simplicity while minimizing (or trying to) friction. A simple tile-based UI would be an ideal solution to support philosophy(6). It would allow the user to use a keyboard and mouse, a touch screen, a gamepad, or any other abstract input devices without any compromises. This could be further extended to allow navigating the entirety of the filesystem from this interface.</p>

<p>If well-executed, we could do away with desktop environments. Although they're highly preferred now on desktop PC's, I believe power-users will become accustomed to these low-friction systems.</p>

<h3>
<a id="developer-tools" class="anchor" href="#developer-tools" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Developer Tools</h3>

<p>Developer tools for many OS' tend to be bloated and not very user friendly. Although we can't strictly avoid legacy toolchains, we can at least provide a better user-experience for developers as part of the OS ecosystem.</p>

<p><strong>Debugger</strong>
One of the things Windows does right that Unix-based OS' do wrong is that Windows provides debugging utilities as part of the kernel. Anyone wishing to implement a custom debugger can simply link against the kernel's public interface library and can get language-agnostic debugging callbacks that any user program can easily interpret and manipulate. We can take this core idea of the debugger being a part of the OS a little further by having executable object parsing, op-code disassembling, and symbol information loading being shipped as part of the debugging API. User-built debuggers don't have to rely on these OS provided utilities, but the advantage to having a standard API for these is that anyone trying to implement a reasonable debugger without large dependencies, can just depend on the OS provided libraries and they should just work.</p>

<p><strong>API deprecation</strong>
Some API designers tend to believe that deprecation is "mark for removal". I don't agree with this idea. A deprecated API should remain available as long as there is software to depend on it. If the API in question breaks one of the core philosophies, it may be justifiable to remove the API from the core OS, but it must still be accessible to any user who wishes to use it through some other means (such as a compatibility package).</p>
      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
